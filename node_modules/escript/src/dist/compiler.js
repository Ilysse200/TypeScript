const compile = (input) => {
    // Helper function to transform function declarations
    const transformFunction = (input) => {
        const transformParameters = (params) => {
            // Handle cases where parameters are empty
            if (!params.trim()) {
                return ''; // Return empty string for no parameters
            }
            // Transform parameters from `type name` to `name: type`
            return params.split(',').map(param => {
                const [type, name] = param.trim().split(/\s+/);
                return `${name}: ${type}`;
            }).join(', ');
        };
        // Define the regex pattern to capture the return type, function name, parameters, and body
        // This pattern accounts for functions with or without access modifiers
        const pattern = /(?:\b(public|private|protected)\s+)?(\basync)\s+?(\w+)\s+(\w+)\s*\(([^)]*)\)\s*{([^}]*)}/g;
        // Define the replacement function for transforming function declarations
        const replacement = (match, accessModifier, async, returnType, funcName, params, body) => {
            const paramList = transformParameters(params);
            // Handle constructor specially
            if (funcName === 'constructor') {
                // Constructors have no return type and do not include the `function` keyword
                return `${accessModifier ? `${accessModifier} ` : ''}constructor(${paramList}) {\n${body}\n}`;
            }
            else {
                // Handle regular functions and methods
                if (accessModifier) {
                    if (async) {
                        // If there is an access modifier, do not include the `function` keyword
                        return `${accessModifier} ${async} ${funcName}(${paramList}): ${returnType ? "Promise<" + returnType + ">" : ''} {\n${body}\n}`;
                    }
                    else {
                        return `${accessModifier} ${funcName}(${paramList}): ${returnType ? returnType : ''} {\n${body}\n}`;
                    }
                }
                else {
                    if (async) {
                        // For standalone functions, include the `function` keyword
                        return `${async} function ${funcName}(${paramList}): ${returnType ? "Promise<" + returnType + ">" : ''} {\n${body}\n}`;
                    }
                    else {
                        return `function ${funcName}(${paramList}): ${returnType ? returnType : ''} {\n${body}\n}`;
                    }
                }
            }
        };
        return input.replace(pattern, replacement);
    };
    // Helper function to transform log statements
    const transformLog = (input) => {
        // Define the regex pattern to capture the log statement and its argument
        const pattern = /log\s+([^;\n]+)(?:;|\n|$)/g;
        // Define the replacement pattern for transforming log statements
        const replacement = 'console.log($1);';
        return input.replace(pattern, replacement);
    };
    // Helper function to transform variable declarations
    const transformVariable = (input) => {
        // Define the regex pattern to capture variable and arrow function declarations, including async
        const pattern = /^(?!\s*type\b)^\s*[\{]*(const|let)?\s*(async\s+)?(\w+(\[\])?)\s+(\w+)\s*=\s*(?:(\([^)]*\)\s*=>.*)|(.+))[\}]*$/gm;
        // Define the replacement function for transforming declarations
        const replacement = (match, declarationKeyword, asyncKeyword, type, arrayBrackets, name, arrowValue, value) => {
            declarationKeyword = declarationKeyword || 'let';
            asyncKeyword = asyncKeyword || '';
            if (arrowValue && arrowValue.trim().startsWith('(')) {
                // Handle arrow function
                const arrowFunctionPattern = /(\([^)]*\))\s*=>\s*({[\s\S]*}|.*)/;
                const [, params, body] = arrowValue.match(arrowFunctionPattern) || [];
                // Transform parameters
                const transformedParams = params.slice(1, -1).split(',').map(param => {
                    const [paramType, paramName] = param.trim().split(/\s+/);
                    return paramType ? `${paramName}: ${paramType}` : '';
                }).join(', ');
                // If the function is async, wrap the return type in Promise
                const returnType = asyncKeyword ? `Promise<${type}>` : type;
                return `${declarationKeyword} ${name} = ${asyncKeyword}(${transformedParams}): ${returnType} => ${body}`;
            }
            else {
                // Handle regular variable
                return `${declarationKeyword} ${name}: ${type}${value ? ` = ${value}` : ''}`;
            }
        };
        return input.replace(pattern, replacement);
    };
    // New helper function to transform await statements
    const transformAwait = (input) => {
        // Define the regex pattern to capture await statements and promises
        const pattern = /\bawait\s+new\s+void\s+Promise\s*\(([^)]*)\)/g;
        // Define the replacement function for transforming await statements
        const replacement = (match, args) => `await new Promise<void>(${args})`;
        let transformed = input.replace(pattern, replacement);
        // Handle cases where await is used with new Promise without the `void` keyword
        transformed = transformed.replace(/\bawait\s+new\s+Promise\s*(\([^)]*\))/g, 'await new Promise$1');
        return transformed;
    };
    // Helper function to transform interface definitions
    const transformInterface = (input) => {
        // Define the regex pattern to capture the interface and its properties
        const pattern = /interface\s+(\w+)\s*{\s*([^}]*)}/g;
        // Define the replacement function for transforming interfaces
        const replacement = (match, name, properties) => {
            const transformedProperties = transformComplexTypes(properties);
            return `interface ${name} {\n    ${transformedProperties}\n}`;
        };
        return input.replace(pattern, replacement);
    };
    // Helper function to transform object assignments
    const transformObjectAssignment = (input) => {
        // Define the regex pattern to capture object assignments
        const pattern = /^(?!\s*type\b)(\w+)\s+(\w+)\s*=\s*{([^}]*)}/gm;
        // Define the replacement pattern for transforming object assignments
        const replacement = 'const $2: $1 = {\n    $3\n}';
        return input.replace(pattern, replacement);
    };
    // Helper function to transform interface properties
    const transformInterfaceProperty = (input) => {
        // Define the regex pattern to capture properties in interface blocks
        const pattern = /(?!\s*interface|log|type|enum|return|await\b)(?<!\S)\b(\w+)\s+(\w+)(?=\s*[\{\}\(\)\[\],;]*\s*(?:\n|\r|$))/g;
        // Define the replacement pattern for transforming properties
        const replacement = '$2: $1';
        return input.replace(pattern, replacement);
    };
    const transformComplexTypes = (input) => {
        // Handle union types and optional types
        const complexTypePattern = /(\w+)\s*(\|?\s*null|\?)?\s+(\w+)\s*;/g;
        return input.replace(complexTypePattern, (match, type, union, name) => {
            const typeWithUnion = union ? `${type}${union.replace('?', '')}` : type;
            return `${name}: ${typeWithUnion};`;
        });
    };
    // Helper function to transform interface definitions
    const transformTypeAlias = (input) => {
        // Define the regex pattern to capture the type alias and its properties
        const pattern = /type\s+(\w+)\s*=\s*{\s*([^}]*)}/g;
        // Define the replacement function for transforming type aliases
        const replacement = (match, name, properties) => {
            const transformedProperties = transformComplexTypes(properties);
            return `type ${name} = {\n    ${transformedProperties}\n}`;
        };
        return input.replace(pattern, replacement);
    };
    const transformClassVariables = (input) => {
        // Define the regex pattern to capture class property declarations
        const classPropertyPattern = /(\bprivate\b|\bpublic\b|\bprotected\b)\s+(\w+)\s+(\w+);/gm;
        // Define the replacement pattern for transforming class properties
        const classPropertyReplacement = '$1 $3: $2;';
        // Apply the transformation
        return input.replace(classPropertyPattern, classPropertyReplacement);
    };
    // Apply all transformations
    let transformed = input;
    transformed = transformTypeAlias(transformed);
    transformed = transformInterface(transformed);
    transformed = transformInterfaceProperty(transformed);
    transformed = transformVariable(transformed);
    transformed = transformFunction(transformed);
    transformed = transformLog(transformed);
    transformed = transformObjectAssignment(transformed);
    transformed = transformClassVariables(transformed);
    transformed = transformAwait(transformed);
    return transformed;
};
export { compile };
