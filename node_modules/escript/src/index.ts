#!/usr/bin/env node
import * as fs from 'fs';
import * as path from 'path';
import { Command } from 'commander';
import { exec } from 'child_process'; // Use exec instead of execSync
import { promisify } from 'util'; // Promisify exec for async/await
import { spawn } from 'child_process'; // Import spawn
import { compile } from './compiler.js';
import chalk from 'chalk';
import ora from 'ora';
import figlet from 'figlet';

const execAsync = promisify(exec); // Create an async version of exec

const program = new Command();

program
    .version('1.0.0')
    .description('Escript Compiler CLI')
    .option('-i, --input <file>', 'Input Escript file')
    .option('-o, --output <file>', 'Output JavaScript/TypeScript file')
    .option('-t, --transpile', 'Transpile TypeScript to JavaScript')
    .option('-r, --run', 'Run the final JavaScript file')
    .action(async (options) => {
        if (!options.input || !options.output) {
            console.log(`${chalk.redBright("[Error]")} No input/output path specified. For more details, please run:`);
            console.log(chalk.green("   npx esc start"));
            return;
        }

        const inputPath = path.resolve(options.input);
        const outputPath = path.resolve(options.output);
        const outputDir = path.dirname(outputPath);
        const isTranspiling = options.transpile;
        const shouldRun = options.run;

        const tempDir = path.join(outputDir, 'temp');
        const tempTsPath = path.join(tempDir, 'temp.ts');

        try {
            const startCompileTime = Date.now();

            // Read the input file asynchronously
            const data = await fs.promises.readFile(inputPath, 'utf8');

            // Compile the Escript code to TypeScript
            const tsOutput = compile(data);
            const compileTime = Date.now() - startCompileTime;
            const compileSpinner = ora(`${chalk.yellow("[Working]")} Compiling to TypeScript...`).start();
            compileSpinner.succeed(`${chalk.green("[Success]")} Compiled to TypeScript: ${tempTsPath} in ${chalk.cyan(compileTime + "ms")}`);

            // Ensure output and temp directories exist
            if (!fs.existsSync(outputDir)) {
                fs.mkdirSync(outputDir, { recursive: true });
            }
            if (!fs.existsSync(tempDir)) {
                fs.mkdirSync(tempDir, { recursive: true });
            }

            // Write the compiled TypeScript code to a temporary file
            fs.writeFileSync(tempTsPath, tsOutput);

            if (isTranspiling) {
                const startTranspileTime = Date.now();

                const outputJsPath = outputPath.replace(/\.ts$/, '.js');
                const quotedTempTsPath = `"${tempTsPath}"`;
                const quotedOutputJsPath = `"${outputJsPath}"`;

                const transpileSpinner = ora(`${chalk.yellow("[Working]")} Transpiling TypeScript to JavaScript...`).start();

                try {
                    await execAsync(`tsc ${quotedTempTsPath} --outFile ${quotedOutputJsPath} --strict`); // Use execAsync instead of execSync
                    const transpileTime = Date.now() - startTranspileTime;
                    transpileSpinner.succeed(`${chalk.green("[Success]")} Transpiled to JavaScript: ${outputJsPath} in ${chalk.cyan(transpileTime + "ms")}`);

                    try {
                        fs.unlinkSync(tempTsPath);
                        fs.rmdirSync(tempDir);
                    } catch (cleanupError: any) {
                        console.log(`${chalk.redBright("[Error]")} Error cleaning up temporary files: ${cleanupError.message}`);
                    }

                    if (shouldRun) {
                        const startExecutionTime = Date.now();

                        const runSpinner = ora(`Running the final JavaScript file...`).start();
                        try {
                            console.log("\n");
                            const child = spawn('node', [quotedOutputJsPath], { stdio: 'inherit', shell: true });

                            // Wait for the child process to exit
                            await new Promise((resolve, reject) => {
                                child.on('close', (code) => {
                                    console.log("\n");
                                    if (code === 0) {
                                        const executionTime = Date.now() - startExecutionTime;
                                        runSpinner.succeed(`${chalk.green("[Success]")} Executed JavaScript file in ${chalk.cyan(executionTime + "ms")}`);
                                        resolve(null);
                                    } else {
                                        runSpinner.fail(`${chalk.redBright("[Error]")} Error running the JavaScript file. Exit code: ${code}`);
                                        reject(new Error(`Exit code: ${code}`));
                                    }
                                });
                            });
                        } catch (runError: any) {
                            runSpinner.fail(chalk.redBright(`${chalk.redBright("[Error]")} Error running the JavaScript file: ${runError.message}`));
                        }
                    }
                } catch (transpileError: any) {
                    transpileSpinner.fail(`${chalk.redBright("[Error]")} Transpilation failed: ${transpileError.message}`);
                }
            }
        } catch (error: any) {
            console.log(chalk.redBright(`${chalk.redBright("[Error]")} ${error.message}`));
        }
    });

program.command("start").description("Get started using the Escript CLI tool").action(() => {
    console.log(figlet.textSync("Escript CLI", { horizontalLayout: 'full' }));
    console.log(chalk.bgBlue("Welcome to the Escript CLI Tool!"));
    console.log(
        "\nEscript is a straightforward scripting language, extending TypeScript with a more C-like syntax to enhance the developer experience. To compile an Escript file, use the following command:"
    );
    console.log(chalk.green("   npx esc -i <input-path> -o <output-path>"));
    console.log(
        "\nAdditionally, you can use these options to manage the compiler:"
    );
    console.log(chalk.green("   -t") + "  : Compile TypeScript (produces JavaScript output)");
    console.log(chalk.green("   -r") + "  : Execute the final JavaScript output");
});

program.parse(process.argv);
